# Архитектура

## Термины
`Правило` - шаблонная структура данных, содержащая данные, которые должны присутствовать в пакете для принятия решения о его блокировке.

## Принцип работы модуля ядра
Модуль ядра на уровне NF_IP_PRE_ROUTING смотрит все проходящие пакеты и сравнивает каждый пакет с `правилом`. Еслив результате сравнения `правило` содержится в пакете, то пакет отбрасывается.
Статистика по пакетам записывается в `/proc/mynetmod/drop_stats`

## Команды

### ioctl - ADD_RULE
Передаёт в модуль правило, которое нухно добавить в список правил.

### ioctl - DEL_RULE
Передаёт в модуль правило, которое нужно удалить из списка правил.

### SHOW
Читвет статичтику из `/proc/mynetmod/drop_stats`  и выводит её пользователю.

## Команды приложения userspace
1. `--ipsrc` - установка ip адреса источника в пакете
2. `--ipdst` - установка ip адреса получателя в пакете
3. `--transport` - установка протокола указанного в пакете
4. `--portsrc` - указывает порт отправителя 
5. `--portdst` - указывает порт получателя
5. `--show` - показывает статистику по правилам.
6. `--filter` - с параметром `enable` добавляет правило в фильтр, с параметром `disable` удаляет правило из фильтра


## Общение kernel-userspace
Для добавления правила в список, userspace-приложение должно вызвать ioctl с одной из следующий команд:
``` C
// Добавление правила в фильтр
#define ADD_RULE _IOWR('a', 'a', struct kern_cmd *)
// Удаление правила из фильтра
#define DEL_RULE _IOWR('a', 'b', struct kern_cmd *)
// Чтение стсатистики из ядра
//#define SHOW _IOR('a', 'c', char *)
```

Обмнен данными происходит с помощью передачи ioctl следующей структуры:
``` C
struct kern_cmd {
	struct kern_rule rule; /* Правило-шаблон для блокировки пакетов */
	uint8_t res; /* Результат операции */
};
```

Само правило:
``` C
struct kern_rule {
	struct in_addr src_ip; /* IPv4 адрес отправителя */
	struct in_addr dst_ip;/* IPv4 адрес получателя */
	uint16_t src_port; /* Порт отправителя */
	uint16_t dst_port; /* Порт получателя */
	uint8_t proto; /* Протокол трансп. уровня (TCP/UDP) */
	uint8_t defined_fields; /* Маска для определения заполненности полей */
	uint32_t blocking_count; /* Статистика блокировок по данному правилу */
};
```

Также есть доп. параметры, которые должны быть одинаковыми в userspace-приложении и в модуле ядра:
``` C
#define NAME_SIZE 64

#define BUF_SIZE 1024

#define SRC_IP_BIT_MASK 	0x1		// 00000001
#define DST_IP_BIT_MASK 	0x2		// 00000010
#define SRC_PORT_BIT_MASK 	0x4		// 00000100
#define DST_PORT_BIT_MASK 	0x8		// 00001000
#define PROTO_BIT_MASK 		0x10	// 00010000
```

### Userspace 
При обработке запроса от пользователя приложение сначала формирует app_cmd (команду от приложения):
``` C
// Структура для хранения параметров
struct app_cmd {
	struct kern_rule rule; /* Правило для передачи в ядро */
	enum { /* Идентификатор что делать с этим правилом или без него */
		CMD_NONE,
		CMD_ADD_RULE,
		CMD_DEL_RULE,
		CMD_SHOW_STATS
	} command;
};
```

Далее приложение формирует структуру команды для ядра `struct kern_cmd` и передаёт с помощью ioctl в ядро (При добавлении и удалении правила). 
Если приложение должно вывести статистику, то оно читает файл `bl_stat`  в  `/proc/<название модуля>`.